\chapter{Аналитический раздел}

\section{Постановка задачи} 

В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуль ядра для ОС Linux, позволяющий скрывать присутствие пользователя в системе.

Чтобы достигнуть поставленной цели, требуется решить следующие задачи:

\begin{itemize}
    \item проанализировать подходы к реализации руткитов;
    \item проанализировать структуры и функции ядра, предоставляющие информацию о процессах и сокетах; 
    \item спроектировать и реализовать загружаемый модуль ядра;
    \item протестировать работоспособность разработанного ПО.
\end{itemize}


\section{Руткиты} 

Руткит --- программа или набор программ, использующих технологии сокрытия системных объектов посредством обхода механизмов системы.
Термин руткит исторически пришел из мира Unix, где под этим термином понимается набор утилит, которые злоумышленник устанавливает на взломанном им компьютере после получения первоначального доступа. Руткит позволяет злоумышленнику получать права суперпользователя, скрывать файлы и процессы, логировать действия пользователя и другое. 

Существует четыре основных вида руткитов:

\begin{itemize}
	\item \textbf{Руткиты пользовательского уровня} запускаются в «пользовательском пространстве». Они перехватывают и изменяют поведение исполняемых файлов, таких как программные файлы и приложения.
	\item \textbf{Руткиты уровня ядра} работают как драйверы или загружаемые модули ядра. ПО, работающее на этом уровне, имеет прямой доступ к аппаратным и системным ресурсам.
	\item \textbf{Буткиты} записывают свой исполняемый код в основной загрузочный сектор жесткого диска. Благодаря этому они могут получить контроль над устройством ещё до запуска операционной системы. Являются разновидностью руткита уровня ядра.
	\item \textbf{Аппаратные руткиты} позволяют скрывать свой исполняемый код внутри архитектуры компьютера, например, в сетевой карте, жестком диске или в BIOS.
\end{itemize}


\section{Сокрытие процессов}%
\label{sec:skrytie_protsessov}
В результате анализа системных вызовов, которые использует утилита
ps, утилитой strace, было выявлено, что каждая операция по
перечислению процессов требует использование системного вызова getdents64
(или её альтернативной реализации для более старых файловых систем —
getdents). Команда ps использует описанный системный вызов для чтения
каталога /proc. Этот системный вызов было решено заменить собственным
обработчиком.

В листинге~\ref{lst:getdents} представлен прототип системного вызова getdents.
\begin{lstlisting}[language=c,caption={Прототип системного вызова getdents},label=lst:getdents]
int getdetns(unsigned int fd, struct linux_dirent *dirp, unsigned int count);    
\end{lstlisting}

Системный вызов getdents читает несколько структур linux\_dirent из каталога, на который указывает fd в область памяти, на которую указывает dirp. Параметр count является размером этой области памяти.

Для использования системного вызова getdents необходимо самостоятельно определить структуру linux\_derent (для getdents64 аналогичная структура уже определена в доступном для пользователя заголовочном файле), которая представлена в листинге~\ref{lst:linux_dirent}.
\begin{lstlisting}[language=c,caption={Структура linux\_dirent},label=lst:linux_dirent]
struct linux_dirent {
    unsigned long	d_ino;
    unsigned long	d_off;
    unsigned short	d_reclen;
    char		d_name[1];
};
\end{lstlisting}

В модифицированной версии функции getdents происходит вызов оригинального системного вызова, после которого происходит проверка на то, соответствует ли название файла идентификатору скрываемого процесса. Если это так, то происходит сокрытие этого файла, что приводит и к сокрытию процесса (от команды ps в частности).


\section{Сокрытие сетевых сокетов}%
\label{sec:skrytie_setevykh_soketov}

Так как каждому сетевому сокету соответствует определенный порт, то
для сокрытия сокета необходимо скрыть соответствующий порт. Для просмотра
портов используется утилита netstat, анализ которой при помощи программы
strace, показал, что для отображения сетевых сокетов выполняется чтение
/proc/net/tcp (tcp6, udp, udp6).

Для работы с файлами виртуальной файловой системы существуют
специальный интерфейс — файловые последовательности, описываемые структурой struct seq\_file.

Для работы с файловыми последовательностями необходимо реализовать
специальные функции. Для упомянутых выше файлов в ядре есть соответствующии им имплементации: tcp4\_seq\_show, udp4\_seq\_show, tcp6\_seq\_show,
udp6\_seq\_show. В листинге~\ref{lst:tcp4_seq_show} представлен прототип одной из них.

\begin{lstlisting}[language=c,caption={Прототип tcp4\_seq\_show},label=lst:tcp4_seq_show]
int tcp4_seq_show(struct seq_file *seq, void *v);
\end{lstlisting}

Среди полей структуры struct seq\_file есть буфер buf, в который происходит запись содержимого файла. За каждый вызов упомянутой функции в этот буфер помещается новая строка.

В рассматриваемом случае, эта строка содержит информацию о сетевом подключении. Чтобы скрыть сетевой сокет, данную строку необходимо удалить из буфера, если в ней содержится номер порта, по которому происходит сокрытие сокета.





\section{Анализ способов перехвата функций в ядре}
Перехват функции заключается в изменении некоторого адреса в памяти процесса или кода в теле функции таким образом, чтобы при вызове этой самой функции управление передавалось не ей, а функции, которая будет её подменять.


\subsection{Linux Security Module}

\texttt{Linux Security Module} (LSM) \cite{linux-security-api} -- это специальный интерфейс, созданный для перехвата функций. В критических местах кода ядра расположены вызовы security-функций, которые вызывают коллбеки (англ. callback \cite{callback}), установленные security-модулем. Данный модуль может изучать контекст операции и принимать решение о её разрешении или запрете \cite{linux-security-api}.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item security-модули являются частью ядра и не могу быть загружены динамически;
	\item в стандартной конфигурации сборки ядра флаг наличия LSM неактивен - большинство уже готовых сборок ядра не содержут внутри себя интерфейс LSM;
	\item в системе может быть только один security-модуль \cite{linux-security-api}.
\end{itemize}

Таким образом, для использования Linux Security Module необходимо поставлять собственную сборку ядра Linux, что является трудоёмким вариантом -- как минимум, придётся тратить время на сборку ядра.

\subsection{Модификация таблицы системных вызовов}

Все обработчики системных вызовов расположены в таблице \texttt{sys\_call\_table}. Подмена значений в этой таблице приведёт к смене поведения всей системы. Сохранив старое значение обработчика и подставив в таблицу собственный обработчик, можно перехватить любой системный вызов.

Особенности данного подхода:

\begin{itemize}
	\item минимальные накладные расходы;
	\item не требуется специальная конфигурация ядра;
	\item техническая сложность реализации -- необходимо модифицировать таблицу системных вызовов;
	\item из-за ряда оптимизаций, реализованных в ядре, некоторые обработчики невозможно перехватить \cite{habr-profiling-linux};
\end{itemize}

\subsection{kprobes}

\texttt{kprobes} \cite{kprobes} -- специальный интерфейс, предназначенный для отладки и трассировки ядра. Данный интерфейс позволяет устанавливать пред- и пост-обработчики для любой инструкции в ядре, а так же обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут изменять их значение \cite{habr-profiling-linux}.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item перехват любой инструкции в ядре -- это реализуется с помощью точек останова (инструкция \texttt{int3}), внедряемых в исполняемый код ядра. Таким образом, можно перехватить любую функцию в ядре;
	\item нетривиальные накладные расходы -- для расстановки и обработки точек останова необходимо большое количество процессорного времени \cite{habr-profiling-linux};
	\item техническая сложность реализации. Так, например, чтобы получить аргументы функции или значения её локальных переменных нужно знать, в каких регистрах, или в каком месте на стеке они находятся, и самостоятельно их оттуда извлекать;
	\item при подмене адреса возврата из функции используется стек, реализованный с помощью буффера фиксированного размера. Таким образом, при большом количестве одновременных вызовов перехваченной функции, могут быть пропущены срабатывания.
\end{itemize}

\subsection{khook}

\texttt{khook} \cite{khook} -- это специальный интерфейс, созданный для перехвата функций. Перехват осуществляется путём замены инструкций в начале функции на безусловный переход, ведущий в
наш обработчик. Оригинальные инструкции переносятся в другое место и
исполняются перед переходом обратно в подменяемую функцию. 

\begin{itemize}
	\item для использования \texttt{khook} не требуется поставлять собственную сборку ядра Linux;
	\item отсутствие задокументированного API;
	\item имеется возможность перехватить любую функцию.
\end{itemize}

\section{Выбор способа перехвата функции в ядре}

Для достижения цели данной работы не подходит способ модификации таблицы
системных вызовов, так как ПО, используемое для обнаружения руткитов в системе, очень часто сравнивает содержимое таблицы системных
вызовов в памяти с содержимым, хранящимся в каталоге /boot. Kprobes в данной работе не дает преимуществ, поскольку требуется больше действий для получения аргументов функции, в сравнении с khook. Для использования Linux Security Module требуется поставлять собственную сборку ядра Linux, что является трудоемким вариантом. В связи с проведенным анализом был выбран метод khook.


\section{Сокрытие загружаемого модуля ядра}%
\label{sec:skrytie_zagruzhaemogo_modulia_iadra}

Загруженные модули ядра можно просмотреть с помощью команды lsmod. lsmod это простая утилита, которая не принимает никаких опций или аргументов. Команда читает /proc/modules и отображает содержимое файла
в отформатированном списке.

Для реализации скрытого руткита необходимо удалить загружаемый модуль с руткитом из основного списка модулей.

Для взаимодействия с двусвязными списками модулей ядра необходимо использовать структуру list\_head.

Удаление из списка происходит с помощью функции list\_del, прототип которой представлен в листинге \ref*{lst:l1}.

\begin{lstlisting}[label=lst:l1, caption=Прототип системного вызова listdel, language=c]
void list_del(struct list_head *entry);
\end{lstlisting}

Добавление в список происходит с помощью функции list\_add, прототип
которой представлен в листинге \ref*{lst:l2}.

\begin{lstlisting}[label=lst:l2, caption=Прототип системного вызова listadd, language=c]
void list_add(struct list_head *new , struct list_head *head);
\end{lstlisting}

Перед удалением загружаемого модуля ядра из списка необходимо сохранить его указатель на этот модуль, чтобы в дальнейшем, во время выгрузки
модуля ядра, можно было вернуть модуль в список.


\section{Структура \texttt{struct task\_struct}}

Каждому процессу в системе соответствует структура \texttt{task\_struct}, которая полностью описывает процесс. Сами структуры связаны друг с другом по средствам кольцевого связанного списка \cite{task-struct}. 

Структура описывает текущее состояние процесса, его флаги, указатель на процессы-потомки и так далее.  В листинге \ref{lst:task-struct} представлено объявление структуры с наиболее важными полями.\\

\begin{lstlisting}[label=lst:task-struct, caption=Листинг структуры task\_struct с наиболее важными полями, language=c]
struct task_struct {
	#ifdef CONFIG_THREAD_INFO_IN_TASK
	struct thread_info		thread_info;
	#endif

	unsigned int			__state;
	...
	unsigned int			flags;
	...
	#ifdef CONFIG_SMP
	int				on_cpu;
	...
	int				recent_used_cpu;
	#endif
	...
	int				recent_used_cpu;
	...
	#ifdef CONFIG_CGROUP_SCHED
	struct task_group		*sched_task_group;
	#endif
	...
	struct sched_info		sched_info;
	...
	struct list_head		tasks;
	...
}
\end{lstlisting}

Для работы с данной структурой внутри ядра объявлен ряд макросов. Например, чтобы обойти все процессы в системе, существует макрос \texttt{for\_each\_process}, который итерируется по связанному списку процессов. Кроме того, существует ряд предописанных констант, позволяющих проверить текущее состояние процесса, например, узнать, выполняется ли процесс в данный момент. Список этих констант приведён в листинге \ref{lst:states}.\\

\begin{lstlisting}[label=lst:states, caption=Описание состояний процесса с помощью предописанных констант, language=c]
#define TASK_RUNNING			0x0000
#define TASK_INTERRUPTIBLE		0x0001
#define TASK_UNINTERRUPTIBLE		0x0002
#define __TASK_STOPPED			0x0004
#define __TASK_TRACED			0x0008
#define EXIT_DEAD			0x0010
#define EXIT_ZOMBIE			0x0020
#define EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)
#define TASK_PARKED			0x0040
#define TASK_DEAD			0x0080
#define TASK_WAKEKILL			0x0100
#define TASK_WAKING			0x0200
#define TASK_NOLOAD			0x0400
#define TASK_NEW			0x0800
#define TASK_RTLOCK_WAIT		0x1000
#define TASK_STATE_MAX			0x2000
#define TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)
#define TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)
#define TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)
#define TASK_IDLE			(TASK_UNINTERRUPTIBLE | TASK_NOLOAD)
#define TASK_NORMAL			(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)
#define TASK_REPORT			(TASK_RUNNING | TASK_INTERRUPTIBLE | \
TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \
__TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \
TASK_PARKED)
\end{lstlisting}

В структуре task\_struct есть поле flags длиной 32 бит. Это поле предназначено для установки и сбрасывания флагов процесса. В листинге 1.8 представлены флаги task\_struct.

\begin{lstlisting}[label=lst:states, caption=Флаги task\_struct, language=c]
	# define PF_IDLE 		0x00000002
	# define PF_EXITING 		0x00000004
	# define PF_VCPU 		0x00000010
	# define PF_WQ_WORKER 		0x00000020
	# define PF_FORKNOEXEC 		0x00000040
	# define PF_MCE_PROCESS 	0x00000080
	# define PF_SUPERPRIV 		0x00000100
	# define PF_DUMPCORE 		0x00000200
	# define PF_SIGNALED 		0x00000400
	# define PF_MEMALLOC 		0x00000800
	# define PF_NPROC_EXCEEDED 	0x00001000
	# define PF_USED_MATH 		0x00002000
	# define PF_USED_ASYNC 		0x00004000
	# define PF_NOFREEZE 		0x00008000
	# define PF_FROZEN 		0x00010000
	# define PF_KSWAPD 		0x00020000
	# define PF_MEMALLOC_NOFS 	0x00040000
	# define PF_MEMALLOC_NOIO 	0x00080000
	# define PF_LOCAL_THROTTLE 	0x00100000
	# define PF_KTHREAD 		0x00200000
	# define PF_RANDOMIZE 		0x00400000
	# define PF_SWAPWRITE 		0x00800000
	# define PF_UMH 		0x02000000
	# define PF_NO_SETAFFINITY 	0x04000000
	# define PF_MCE_EARLY 		0x08000000
	# define PF_MEMALLOC_NOCMA 	0x10000000
	# define PF_IO_WORKER 		0x20000000
	# define PF_FREEZER_SKIP 	0x40000000
	# define PF_SUSPEND_TASK 	0x80000000
\end{lstlisting}

Исходя из этого листинга можно сделать вывод, что не все разряды flags
соответствуют тем или иным флагам. Поэтому, для того, чтобы установить,
скрыт процесс или нет, зарезервируем один из свободных разрядов.

\section{Выводы}%
\label{sec:vyvody}

В результате проведенного анализа было принято решение использовать загружаемый модуль ядра для реализации руткита. Данный подход обеспечивает наименьшую вероятность обнаружения антивирусными программами. Также данный подход позволяет расширять функциональность руткита без необходимости перекомпилировать ядро. Для перехвата системных вызовов было принято решение использовать библиотеку khook. Также были найдены и проанализированы системные вызовы, которые необходимо подменить для выполнения поставленной задачи.
